[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "thesis",
    "section": "",
    "text": "0.1 Quarto\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>thesis</span>"
    ]
  },
  {
    "objectID": "estudio.html",
    "href": "estudio.html",
    "title": "Estudio de caso",
    "section": "",
    "text": "Adaptación de PageRank a redes territoriales del estado de Chiapas: Un enfoque basado en cadenas de Markov",
    "crumbs": [
      "Estudio de caso"
    ]
  },
  {
    "objectID": "estudio.html#adaptación-de-pagerank-a-redes-territoriales-del-estado-de-chiapas-un-enfoque-basado-en-cadenas-de-markov",
    "href": "estudio.html#adaptación-de-pagerank-a-redes-territoriales-del-estado-de-chiapas-un-enfoque-basado-en-cadenas-de-markov",
    "title": "Estudio de caso",
    "section": "Problemas en la red y solución de PageRank",
    "text": "En situaciones de emergencia, como desastres naturales o crisis humanitarias, es fundamental contar con mecanismos eficientes para distribuir ayuda y recursos a la población afectada. En regiones como el estado de Chiapas que cuenta con 124 municipios según el INEGI, contando con una geografía montañosa y la dispersión de los municipios dificultan la conectividad, se vuelve especialmente importante identificar puntos estratégicos dentro de la red territorial que puedan facilitar la logística y la respuesta rápida.\nPara abordar este desafío, se propone aplicar el algoritmo PageRank, desarrollado por Larry Page y Sergey Brin como parte del motor de búsqueda de Google, con el fin de priorizar municipios según su importancia dentro de la red de transporte intermunicipal. Este algoritmo, basado en un modelo de cadenas de Markov, mide la relevancia de cada nodo (municipio) al simular el recorrido de un “navegante aleatorio” que transita la red con cierta probabilidad de seguir conexiones o saltar aleatoriamente a otro nodo.\nEn términos prácticos, PageRank estima la probabilidad estacionaria de una cadena de Markov con un número finito de estados describiendo la fracción de tiempo que, en promedio, el sistema permanece en cada estado cuando se observa durante un periodo suficientemente largo (REFERENCIA), lo cual permite identificar aquellos municipios que, por su posición estratégica y conectividad, tienen mayor influencia dentro del sistema territorial. Esta información es clave para diseñar estrategias de distribución de ayuda, optimización de rutas y toma de decisiones en situaciones críticas.\nEn este estudio de caso, se aplica PageRank a la red territorial del estado de Chiapas, representando los municipios como nodos y las rutas entre ellos como enlaces ponderados por distancia. El objetivo es obtener una clasificación de los municipios más centrales o influyentes, que puedan actuar como puntos clave en escenarios de distribución logística.\n\nProblemas en la red y solución de PageRank\nEn el análisis de una red de nodos, existen dos factores que pueden obstaculizar la convergencia hacia una distribución estacionaria, estos factores son: - los nodos colgantes - subgrafos ansorbentes\n\nNodos colgantes\nLos nodos colgantes hace referencia a las páginas que no tiene enlaes de salida. En el contexto de una red territorial, este fenómeno se manifiesta en municipios que no tienen conexión con otros municipios. En el caso del estado de Chiapas, no se identificaron nodos colgantes en la red analizada.\nEl algoritmo PageRank soluciona este problema modificando la matriz de red. Sea \\(N\\) la matriz de red (REFERENCIA), donde cada entrada \\(n_{ij}\\) representa la conexión desde el nodo \\(j\\) hacia el nodo \\(i\\), donde \\(i,j \\in \\mathbb{N}\\). Para abordar el problema de nodos colgantes, se redefine la matriz de transición \\(Q\\) donde la entrada \\(i\\) que tiene entradas cero (nodos colgantes) se remplaza por \\(\\frac{1}{k}\\) donde \\(k\\) es número totales de páginas o municipios, esta corrección nos garantiza que la matriz de trancisión \\(Q\\) sea estocástica.\n\n\nSubgrafos absorbentes\nCuando existen subgrafos absorbentes dentro de la red. Estos corresponden a conjuntos de páginas (o nodos) que están interconectados entre sí pero no tienen enlaces de salida hacia el resto de la red, es decir, hacen un ciclo. En el contexto de la red territorial, esto se representa en los municipios que únicamente estan conectados entres sí, formando un subconjunto cerrado que puede atrapar al navegante en un ciclo sin posibilidad de salir.\nPara resolver este problema, los creadores del algoritmo PageRank introdujeron un mecanismo llamado factor de amortiguación. Este consiste en asumir de la red una probabilidad \\(1-p\\) de teletranspotarse aleatoriamente a cualquier otro nodo del grafo.\nUsualmente se toma \\(p=0.85\\), esto significa que en un \\(85\\%\\) de los casos el navegante sigue los enklaces y el \\(15\\%\\) restante salta aleatoriamente a cualquier otro nodo.\nCon los ajustes mencionados se obtene una matriz de trasción modificada que se define como: \\[P:= p Q +(1-p)A\\] donde, \\(A\\) es una matriz cuadrada con todas las entradas \\(\\dfrac{1}{k}\\) representando una conexión aleatoria uniforme. La matriz resultante \\(P\\) garantiza que el algoritmo funcione correctamente y siempre llegue a una solución estable, debido a que al ser estocástica, asegura que desde cada nodo siempre conserve la probabilidad total en cada pso del proceso; al ser aperiódica, evita que el sistema quede atrapado en ciclos repetitivos; y al ser irreducible, garantiza que todos los nodos estén conectados de alguna forma, permitiendo que eventualmente se pueda llegar a cualquier parte de la red.",
    "crumbs": [
      "Estudio de caso"
    ]
  },
  {
    "objectID": "estudio.html#problemas-en-la-red-y-solución-de-pagerank",
    "href": "estudio.html#problemas-en-la-red-y-solución-de-pagerank",
    "title": "Estudio de caso",
    "section": "",
    "text": "En el análisis de una red de nodos, existen dos factores que pueden obstaculizar la convergencia hacia una distribución estacionaria, estos factores son: - los nodos colgantes - subgrafos ansorbentes\n\nNodos colgantes\nLos nodos colgantes hace referencia a las páginas que no tiene enlaes de salida. En el contexto de una red territorial, este fenómeno se manifiesta en municipios que no tienen conexión con otros municipios. En el caso del estado de Chiapas, no se identificaron nodos colgantes en la red analizada.\nEl algoritmo PageRank soluciona este problema modificando la matriz de red. Sea \\(N\\) la matriz de red (REFERENCIA), donde cada entrada \\(n_{ij}\\) representa la conexión desde el nodo \\(j\\) hacia el nodo \\(i\\), donde \\(i,j \\in \\mathbb{N}\\). Para abordar el problema de nodos colgantes, se redefine la matriz de transición \\(Q\\) donde la entrada \\(i\\) que tiene entradas cero (nodos colgantes) se remplaza por \\(\\frac{1}{k}\\) donde \\(k\\) es número totales de páginas o municipios, esta corrección nos garantiza que la matriz de trancisión \\(Q\\) sea estocástica.\n\n\nSubgrafos absorbentes\nCuando existen subgrafos absorbentes dentro de la red. Estos corresponden a conjuntos de páginas (o nodos) que están interconectados entre sí pero no tienen enlaces de salida hacia el resto de la red, es decir, hacen un ciclo. En el contexto de la red territorial, esto se representa en los municipios que únicamente estan conectados entres sí, formando un subconjunto cerrado que puede atrapar al navegante en un ciclo sin posibilidad de salir.\nPara resolver este problema, los creadores del algoritmo PageRank introdujeron un mecanismo llamado factor de amortiguación. Este consiste en asumir de la red una probabilidad \\(1-p\\) de teletranspotarse aleatoriamente a cualquier otro nodo del grafo.\nUsualmente se toma \\(p=0.85\\), esto significa que en un \\(85\\%\\) de los casos el navegante sigue los enklaces y el \\(15\\%\\) restante salta aleatoriamente a cualquier otro nodo.\nCon los ajustes mencionados se obtene una matriz de trasción modificada que se define como: \\[P:= p Q +(1-p)A\\] donde, \\(A\\) es una matriz cuadrada con todas las entradas \\(\\dfrac{1}{k}\\) representando una conexión aleatoria uniforme. La matriz resultante \\(P\\) garantiza que el algoritmo funcione correctamente y siempre llegue a una solución estable, debido a que al ser estocástica, asegura que desde cada nodo siempre conserve la probabilidad total en cada pso del proceso; al ser aperiódica, evita que el sistema quede atrapado en ciclos repetitivos; y al ser irreducible, garantiza que todos los nodos estén conectados de alguna forma, permitiendo que eventualmente se pueda llegar a cualquier parte de la red.",
    "crumbs": [
      "Estudio de caso"
    ]
  },
  {
    "objectID": "metodologia.html",
    "href": "metodologia.html",
    "title": "4  Metodología",
    "section": "",
    "text": "4.1 Recolección de datos\nTable 4.1: Distancias de carreteras en Chiapas (3D)\n\n\n\n\n    \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n    Loading ITables v2.4.4 from the internet...\n    (need help?)",
    "crumbs": [
      "Estudio de caso",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Metodología</span>"
    ]
  },
  {
    "objectID": "metodologia.html#recolección-de-datos",
    "href": "metodologia.html#recolección-de-datos",
    "title": "4  Metodología",
    "section": "4.2 “Cálculo de distancia 3D de rutas geográficas usando datos OSRM y elevación”",
    "text": "El estudio utilizó dos fuentes principales de datos geoespaciales:\n\nDatos de rutas:\n\nObtenidos mediante la API de Open Source Routing Machine (OSRM).\nEl formato usado son Coordenadas geográficas en WGS84 ([latitud, longitud]) para cada punto de la ruta.\n\nDatos de elevación:\n\nLa información utilizada proviene del Modelo Digital de Elevación (DEM) generado por la misión Shuttle Radar Topography Mission (SRTM) de la NASA, disponible en NASA Earthdata (https://earthdata.nasa.gov/). Los datos cuentan con una resolución espacial de 30 metros y se distribuyen en teselas de \\(1^{\\circ} \\times 1^{\\circ}\\) de latitud y longitud. Cada archivo ráster SRTM está conformado por una malla regular de celdas (pixeles), en la cual cada celda almacena un valor de elevación del terreno expresado en metros sobre el nivel del mar (m s. n. m.). Para cubrir áreas de mayor extensión, como un estado, un país o una región montañosa, es necesario integrar estas teselas, lo que permite generar una capa continua y sin discontinuidades del relieve, denominada mosaico ráster.\n\n\n\n4.2 “Cálculo de distancia 3D de rutas geográficas usando datos OSRM y elevación”\nPara estimar la longitud real de una carretera considerando las variaciones de altitud del terreno, se utiliza una formulación basada en la distancia geodésica entre puntos sucesivos de una ruta, combinada con la diferencia de elevaciones. Esto permite obtener una distancia tridimensional (3D) más realista, que considera tanto la curvatura terrestre como los cambios topográficos.\nSea una ruta discretizada por \\(N\\) puntos geográficos con coordenadas: \\(P_i= (\\phi_i, \\lambda_i\\)) para \\(i=1, \\cdots, N\\) donde: \\(\\phi_i\\) es la latitud de punto \\(i\\) y \\(\\lambda_i\\) es la longitud del punto \\(i\\).   La distancia superficial (2D) entre dos puntos consecutivos se calcula utilizando la fórmula de Vincenty o usando elipsoide WGS84 (World Geodetic System 1984), el cual se calcula mediante la siguiente expresión  \\[\n d_i^{2D}:= GeodInv(\\phi_{i-1}, \\lambda_{i-1}, \\phi_i, \\lambda_i),\n \\]\nque representa la distancia geodésica 2D entre los puntos \\(P_{i-1}\\) y \\(P_{i},\\) calculada sobre la superficie de la Tierra.\nPor otro lado, para estimar la distancia real de una carretera, considerando las variaciones del terreno (con elevación), se considera la ruta como una secuencia de puntos geográficos \\(P_i= (\\phi_i, \\lambda_i\\)) y \\(h_i\\) la elevación en metros sobre el nivel del mar del punto \\(i,\\) extraÍda del mosaico ráster de altitudes mediente la interpolacion espacial. La distancia entre dos puntos consecutivos se calcula como \\[\nd_i^{3D} := \\sqrt{(d_i^{2D})^2+(\\Delta h_i)^2},\n\\] siendo \\(\\Delta h_i= h_i-h_{i-1}\\) el cambio de altitud entre dos puntos consecutivos.\nLa distancia total proyectada (2D) y la distancia real sobre el terreno (3D) son respectivamente \\[\nD^{(2D)}:= \\sum_{i=1}^{N-1} d_i^{(2D)},\n\\] y \\[\nD^{(3D)}:= \\sum_{i=1}^{N-1} d_i^{(3D)}.\n\\]\n\n\n\nCode\nfrom google.colab import drive\nimport requests\nimport csv\nimport time\nfrom urllib.parse import quote\nimport folium\nimport math\nimport rasterio\nfrom rasterio.merge import merge\nfrom shapely.geometry import LineString\nimport numpy as np\nfrom pyproj import Geod\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom IPython.display import display\n\n# Montar Google Drive\ndrive.mount('/content/drive')\n\n# Instalar librerías necesarias\n!pip install rasterio geopandas pyproj folium\n\n# Configuración de ciudades\nciudades = [\n    \"Acacoyagua\", \"Acala\", \"Acapetahua\", \"Aldama\", \"Altamirano\", \"Amatán\", \n    \"Amatenango de la Frontera\", \"Amatenango del Valle\", \"Ángel Albino Corzo\",\n    \"Arriaga\", \"Bejucal de Ocampo\", \"Bella Vista\", \n    \"Benemérito de las Américas\",\"Berriozábal\", \"Bochil\", \"Cacahoatán\", \n    \"Capitán Luis Ángel Vidal\", \"Catazajá\", \"Chalchihuitán\", \"Chamula\", \n    \"Chanal\", \"Chapultenango\",\"Chenalhó\", \"Chiapa de Corzo\", \"Chiapilla\", \n    \"Chicoasén\", \"Chicomuselo\", \"Chilón\",\"Cintalapa de Figueroa\", \"Coapilla\", \n    \"Comitán de Domínguez\", \"Copainalá\", \"El Bosque\", \"El Parral\",\n    \"El Porvenir\", \"Emiliano Zapata\", \"Escuintla\", \"Francisco León\", \n    \"Frontera Comalapa\", \"Frontera Hidalgo\", \"Honduras de la Sierra\",\n    \"Huehuetán\", \"Huitiupán\", \"Huixtán\", \"Huixtla\", \"Ixhuatán\",\n    \"Ixtacomitán\", \"Ixtapa\", \"Ixtapangajoya\", \"Jiquipilas\", \"Jitotol\", \n    \"Juárez\", \"La Concordia\", \"La Grandeza\", \"La Independencia\", \n    \"La Libertad\", \"La Trinitaria\", \"Larráinzar\", \"Las Margaritas\", \n    \"Las Rosas\", \"Mapastepec\", \"Maravilla Tenejapa\", \"Marqués de Comillas\",\n    \"Mazapa de Madero\", \"Mazatán\", \"Metapa\", \"Mezcalapa\"  \"Mitontic\", \n    \"Montecristo de Guerrero\", \"Motozintla\", \"Nicolás Ruíz\", \"Ocosingo\", \n    \"Ocotepec\", \"Ocozocoautla de Espinosa\", \"Ostuacán\", \"Osumacinta\", \n    \"Oxchuc\", \"Palenque\", \"Pantelhó\", \"Pantepec\", \"Pichucalco\",\n    \"Pijijiapan\", \"Pueblo Nuevo Solistahuacán\", \"Rayón\", \"Reforma\", \n    \"Rincón Chamula San Pedro\", \"Sabanilla\", \"Salto de Agua\", \n    \"San Andrés Duraznal\", \"San Cristóbal de las Casas\", \"San Fernando\", \n    \"San Juan Cancuc\", \"San Lucas\", \"Santiago el Pinar\", \"Siltepec\", \n    \"Simojovel\", \"Sitalá\", \"Socoltenango\", \"Solosuchiapa\", \"Soyaló\", \n    \"Suchiapa\", \"Suchiate\", \"Sunuapa\", \"Tapachula\", \"Tapalapa\", \"Tapilula\",\n    \"Tecpatán\", \"Tenejapa\", \"Teopisca\", \"Tila\", \"Tonalá\", \"Totolapa\",\n    \"Tumbalá\", \"Tuxtla Chico\", \"Tuxtla Gutiérrez\", \"Tuzantán\", \"Tzimol\", \n    \"Unión Juárez\", \"Venustiano Carranza\",  \"Villa Comaltitlán\", \n    \"Villa Corzo\", \"Villaflores\", \"Yajalón\", \"Zinacantán\"\n]\nciudades.sort()\n\n# Funciones auxiliares\ndef cargar_mosaico_srtm():\n    archivos_hgt = [\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N17W094.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N17W093.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N17W092.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N16W095.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N16W094.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N16W093.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N15W094.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N15W092.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N14W093.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N16W091.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N15W093.hgt\",\n        \"/content/drive/MyDrive/thesis/chiapas_hgt/N16W092.hgt\"\n    ]\n    src_files = [rasterio.open(f) for f in archivos_hgt]\n    mosaico, transform = merge(src_files)\n    for src in src_files:\n        src.close()\n    return mosaico, transform\n\ndef obtener_coordenadas(ciudad):\n    url = f\"https://nominatim.openstreetmap.org/search?q=\n        {quote(ciudad+', Chiapas, México')}&format=json\"\n    response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n    data = response.json()\n    if data:\n        return (float(data[0]['lat']), float(data[0]['lon']))\n    return None\n\ndef obtener_ruta_osrm(coord_origen, coord_destino):\n    lon1, lat1 = coord_origen[1], coord_origen[0]\n    lon2, lat2 = coord_destino[1], coord_destino[0]\n    url = f\"http://router.project-osrm.org/route/v1/driving/{lon1},{lat1};\n        {lon2},{lat2}?overview=full&geometries=geojson\"\n    try:\n        response = requests.get(url)\n        data = response.json()\n        if data['code'] == 'Ok':\n            distancia = data['routes'][0]['distance']\n            duracion = data['routes'][0]['duration']\n            geometria = data['routes'][0]['geometry']['coordinates']\n            return distancia, duracion, [(lat, lon) for lon, lat in geometria]\n    except Exception as e:\n        print(f\"Error OSRM: {e}\")\n    return None, None, None\n\ndef calcular_distancia_3d_ruta(mosaico, transform, ruta_coords):\n    geod = Geod(ellps=\"WGS84\")\n    distancia_3d = 0\n    distancia_2d = 0\n    elevaciones = []\n    for coord in ruta_coords:\n        lon, lat = coord[1], coord[0]\n        try:\n            col, row = ~transform * (lon, lat)\n            elev = mosaico[0, int(row), int(col)]\n            elevaciones.append(elev)\n        except:\n            elevaciones.append(np.nan)\n    for i in range(1, len(ruta_coords)):\n        lon1, lat1 = ruta_coords[i-1][1], ruta_coords[i-1][0]\n        lon2, lat2 = ruta_coords[i][1], ruta_coords[i][0]\n        elev1, elev2 = elevaciones[i-1], elevaciones[i]\n        if np.isnan(elev1) or np.isnan(elev2):\n            continue\n        _, _, dist2d = geod.inv(lon1, lat1, lon2, lat2)\n        delta_elev = elev2 - elev1\n        dist3d = math.sqrt(abs(dist2d**2 + delta_elev**2)) \n        distancia_2d += dist2d\n        distancia_3d += dist3d\n    return distancia_2d, distancia_3d, elevaciones\n\n# Proceso principal\nmosaico, transform = cargar_mosaico_srtm()\ncoordenadas = {}\nprint(\"Obteniendo coordenadas...\")\nfor ciudad in ciudades:\n    coord = obtener_coordenadas(ciudad)\n    if coord:\n        coordenadas[ciudad] = coord\n        print(f\"{ciudad}: {coord[0]:.4f}, {coord[1]:.4f}\")\n    time.sleep(1)\n\narchivo_salida =\n    \"/content/drive/MyDrive/thesis/ponencia_pagerank_distancia_chiapas\n    /distancias_chiapas_carreteras_3d_completo.csv\"\nwith open(archivo_salida, \"w\", newline=\"\", \n    encoding=\"utf-8\") as file:\n    writer = csv.writer(file)\n    writer.writerow([\"Origen\", \"Destino\", \"Distancia carretera (km)\", \n        \"Distancia 3D (km)\", \"Diferencia (km)\", \"Tiempo estimado (min)\"])\n\n    mapa = folium.Map(location=[16.75, -92.62], zoom_start=8)\n    colores = ['red', 'blue', 'green', 'purple', 'orange', 'darkred']\n\n    for i in range(len(ciudades)):\n        for j in range(len(ciudades)):\n            if i == j:\n                continue\n            origen = ciudades[i]\n            destino = ciudades[j]\n            if origen in coordenadas and destino in coordenadas:\n                print(f\"\\nCalculando {origen} → {destino}...\")\n                coord_origen = coordenadas[origen]\n                coord_destino = coordenadas[destino]\n                distancia_ruta, duracion, ruta_coords = \n                    obtener_ruta_osrm(coord_origen, coord_destino)\n                if ruta_coords:\n                    dist2d, dist3d, elevaciones =\n                        calcular_distancia_3d_ruta(mosaico, transform,\n                             ruta_coords)\n                    if dist2d &gt; 0 and dist3d &gt; 0:\n                        dist_ruta_km = distancia_ruta/1000\n                        dist3d_km = dist3d/1000\n                        diferencia = dist3d_km - dist_ruta_km\n                        tiempo_min = duracion/60\n                        writer.writerow([origen, destino,\n                            round(dist_ruta_km, 3), round(dist3d_km, 3),\n                            round(diferencia, 3), round(tiempo_min, 1)])\n                        color = colores[(i+j) % len(colores)]\n                        folium.PolyLine(locations=ruta_coords, color=color,\n                                        weight=3, opacity=0.7,tooltip=\n                                        f\"{origen} → {destino}&lt;br&gt;Distancia:\n                                        {dist_ruta_km:.1f}km&lt;br&gt;Tiempo:\n                                        {tiempo_min:.1f}min\").add_to(mapa)\n                        folium.Marker(location=coord_origen, popup=origen, \n                            icon=folium.Icon(color='green')).add_to(mapa)\n                        folium.Marker(location=coord_destino, popup=destino, \n                            icon=folium.Icon(color='red')).add_to(mapa)\n                time.sleep(1)\n\nprint(f\"\\n Datos guardados en {archivo_salida}\")\nprint(\" Mapa actualizado con rutas en ambas direcciones\")\n\n# Mostrar mapa directamente en Colab\ndisplay(mapa)\n\n# Mostrar CSV resultante\ndf = pd.read_csv(archivo_salida)\ndisplay(df)\n\n\n\n\n\n\n\n\n\n\nMapa de Chiapas",
    "crumbs": [
      "Estudio de caso",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Metodología</span>"
    ]
  },
  {
    "objectID": "metodologia.html#cálculo-de-distancia-3d-de-rutas-geográficas-usando-datos-osrm-y-elevación",
    "href": "metodologia.html#cálculo-de-distancia-3d-de-rutas-geográficas-usando-datos-osrm-y-elevación",
    "title": "4  Metodología",
    "section": "",
    "text": "Para estimar la longitud real de una carretera considerando las variaciones de altitud del terreno, se utiliza una formulación basada en la distancia geodésica entre puntos sucesivos de una ruta, combinada con la diferencia de elevaciones. Esto permite obtener una distancia tridimensional (3D) más realista, que considera tanto la curvatura terrestre como los cambios topográficos.\nSea una ruta discretizada por \\(N\\) puntos geográficos con coordenadas: \\(P_i= (\\phi_i, \\lambda_i\\)) para \\(i=1, \\cdots, N\\) donde: \\(\\phi_i\\) es la latitud de punto \\(i\\) y \\(\\lambda_i\\) es la longitud del punto \\(i\\).   La distancia superficial (2D) entre dos puntos consecutivos se calcula utilizando la fórmula de Vincenty o usando elipsoide WGS84 (World Geodetic System 1984), el cual se calcula mediante la siguiente expresión  \\[\n d_i^{2D}:= GeodInv(\\phi_{i-1}, \\lambda_{i-1}, \\phi_i, \\lambda_i),\n \\]\nque representa la distancia geodésica 2D entre los puntos \\(P_{i-1}\\) y \\(P_{i},\\) calculada sobre la superficie de la Tierra.\nPor otro lado, para estimar la distancia real de una carretera, considerando las variaciones del terreno (con elevación), se considera la ruta como una secuencia de puntos geográficos \\(P_i= (\\phi_i, \\lambda_i\\)) y \\(h_i\\) la elevación en metros sobre el nivel del mar del punto \\(i,\\) extraÍda del mosaico ráster de altitudes mediente la interpolacion espacial. La distancia entre dos puntos consecutivos se calcula como \\[\nd_i^{3D} := \\sqrt{(d_i^{2D})^2+(\\Delta h_i)^2},\n\\] siendo \\(\\Delta h_i= h_i-h_{i-1}\\) el cambio de altitud entre dos puntos consecutivos.\nLa distancia total proyectada (2D) y la distancia real sobre el terreno (3D) son respectivamente \\[\nD^{(2D)}:= \\sum_{i=1}^{N-1} d_i^{(2D)},\n\\] y \\[\nD^{(3D)}:= \\sum_{i=1}^{N-1} d_i^{(3D)}.\n\\]",
    "crumbs": [
      "Estudio de caso",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Metodología</span>"
    ]
  },
  {
    "objectID": "mapa.html",
    "href": "mapa.html",
    "title": "6  Mapa con Folium",
    "section": "",
    "text": "7 Mapa interactivo con Folium\n\n\nCode\nimport folium\n\n# Crear el mapa centrado en Tuxtla Gutiérrez\nmapa = folium.Map(location=[16.7529, -93.1169], zoom_start=13)\n\n# Agregar un marcador\nfolium.Marker(\n    [16.7529, -93.1169],\n    tooltip=\"Tuxtla Gutiérrez\",\n    popup=\"Capital de Chiapas\"\n).add_to(mapa)\n\n# Guardar el mapa como archivo HTML para Selenium\nmapa.save(\"mapa_folium.html\")\n\n\n\n\n\nCode\nimport IPython\nIPython.display.display(mapa)\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n\n\nCode\n# Captura del mapa como imagen PNG para incluir en PDF\n# Captura del mapa como imagen PNG para incluir en PDF\nimport os\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nfrom PIL import Image\nimport time\n\nif not os.path.exists(\"mapa_folium.png\"):\n    options = Options()\n    options.add_argument('--headless')\n    options.add_argument('--disable-gpu')\n    options.add_argument('--disable-dev-shm-usage')\n    options.add_argument(\"--window-size=800,600\")\n\n    driver = webdriver.Chrome(options=options)\n\n    driver.get(\"file://\" + os.path.abspath(\"mapa_folium.html\"))\n    time.sleep(2)  # Esperar a que cargue el mapa\n\n    # Forzar fondo blanco (evita fondo negro)\n    driver.execute_script(\"document.body.style.background = 'white';\")\n\n    # Intentar capturar el contenedor del mapa directamente\n    try:\n        map_element = driver.find_element(\"id\", \"map\")\n        map_element.screenshot(\"mapa_folium.png\")\n    except:\n        # Si no encuentra el ID, captura toda la pantalla y recorta\n        driver.save_screenshot(\"mapa_folium_full.png\")\n        img = Image.open(\"mapa_folium_full.png\")\n        crop = img.crop((0, 0, 800, 600))\n        crop.save(\"mapa_folium.png\")\n\n    driver.quit()\n\n\n\n\n\n\nMapa generado con Folium",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Mapa con Folium</span>"
    ]
  }
]